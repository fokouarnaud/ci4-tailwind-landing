import { APP_CONFIG } from './constants.js';\n\n// DOM utility functions\nexport const dom = {\n  // Get element by selector\n  get: (selector) => document.querySelector(selector),\n  \n  // Get all elements by selector\n  getAll: (selector) => document.querySelectorAll(selector),\n  \n  // Create element with attributes\n  create: (tag, attributes = {}, children = []) => {\n    const element = document.createElement(tag);\n    \n    // Set attributes\n    Object.entries(attributes).forEach(([key, value]) => {\n      if (key === 'className') {\n        element.className = value;\n      } else if (key === 'textContent') {\n        element.textContent = value;\n      } else {\n        element.setAttribute(key, value);\n      }\n    });\n    \n    // Append children\n    children.forEach(child => {\n      if (typeof child === 'string') {\n        element.appendChild(document.createTextNode(child));\n      } else {\n        element.appendChild(child);\n      }\n    });\n    \n    return element;\n  },\n  \n  // Check if element is in viewport\n  isInViewport: (element) => {\n    const rect = element.getBoundingClientRect();\n    return (\n      rect.top >= 0 &&\n      rect.left >= 0 &&\n      rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&\n      rect.right <= (window.innerWidth || document.documentElement.clientWidth)\n    );\n  },\n  \n  // Get element's offset from top of document\n  getOffset: (element) => {\n    const rect = element.getBoundingClientRect();\n    return {\n      top: rect.top + window.pageYOffset,\n      left: rect.left + window.pageXOffset,\n    };\n  },\n};\n\n// Storage utilities\nexport const storage = {\n  // Local storage with JSON support\n  set: (key, value) => {\n    try {\n      localStorage.setItem(key, JSON.stringify(value));\n      return true;\n    } catch (error) {\n      console.error('Storage set error:', error);\n      return false;\n    }\n  },\n  \n  get: (key, defaultValue = null) => {\n    try {\n      const item = localStorage.getItem(key);\n      return item ? JSON.parse(item) : defaultValue;\n    } catch (error) {\n      console.error('Storage get error:', error);\n      return defaultValue;\n    }\n  },\n  \n  remove: (key) => {\n    try {\n      localStorage.removeItem(key);\n      return true;\n    } catch (error) {\n      console.error('Storage remove error:', error);\n      return false;\n    }\n  },\n  \n  clear: () => {\n    try {\n      localStorage.clear();\n      return true;\n    } catch (error) {\n      console.error('Storage clear error:', error);\n      return false;\n    }\n  },\n};\n\n// URL utilities\nexport const url = {\n  // Get current pathname\n  getCurrentPath: () => window.location.pathname,\n  \n  // Get query parameters as object\n  getParams: () => {\n    const params = new URLSearchParams(window.location.search);\n    const result = {};\n    for (const [key, value] of params) {\n      result[key] = value;\n    }\n    return result;\n  },\n  \n  // Get specific query parameter\n  getParam: (name, defaultValue = null) => {\n    const params = new URLSearchParams(window.location.search);\n    return params.get(name) || defaultValue;\n  },\n  \n  // Navigate to URL\n  navigate: (url, replace = false) => {\n    if (replace) {\n      window.location.replace(url);\n    } else {\n      window.location.href = url;\n    }\n  },\n};\n\n// Throttle and debounce utilities\nexport const performance = {\n  // Throttle function execution\n  throttle: (func, delay) => {\n    let timeoutId;\n    let lastExecTime = 0;\n    \n    return function (...args) {\n      const currentTime = Date.now();\n      \n      if (currentTime - lastExecTime > delay) {\n        func.apply(this, args);\n        lastExecTime = currentTime;\n      } else {\n        clearTimeout(timeoutId);\n        timeoutId = setTimeout(() => {\n          func.apply(this, args);\n          lastExecTime = Date.now();\n        }, delay - (currentTime - lastExecTime));\n      }\n    };\n  },\n  \n  // Debounce function execution\n  debounce: (func, delay) => {\n    let timeoutId;\n    \n    return function (...args) {\n      clearTimeout(timeoutId);\n      timeoutId = setTimeout(() => func.apply(this, args), delay);\n    };\n  },\n  \n  // Request animation frame wrapper\n  raf: (callback) => {\n    return window.requestAnimationFrame(callback);\n  },\n};\n\n// Screen size utilities\nexport const screen = {\n  // Get current breakpoint\n  getCurrentBreakpoint: () => {\n    const width = window.innerWidth;\n    const breakpoints = APP_CONFIG.BREAKPOINTS;\n    \n    if (width >= breakpoints['2xl']) return '2xl';\n    if (width >= breakpoints.xl) return 'xl';\n    if (width >= breakpoints.lg) return 'lg';\n    if (width >= breakpoints.md) return 'md';\n    if (width >= breakpoints.sm) return 'sm';\n    return 'xs';\n  },\n  \n  // Check if screen is at least a certain breakpoint\n  isAtLeast: (breakpoint) => {\n    const width = window.innerWidth;\n    return width >= APP_CONFIG.BREAKPOINTS[breakpoint];\n  },\n  \n  // Check if screen is below a certain breakpoint\n  isBelow: (breakpoint) => {\n    const width = window.innerWidth;\n    return width < APP_CONFIG.BREAKPOINTS[breakpoint];\n  },\n};\n\n// Form utilities\nexport const form = {\n  // Serialize form data to object\n  serialize: (formElement) => {\n    const formData = new FormData(formElement);\n    const result = {};\n    for (const [key, value] of formData) {\n      if (result[key]) {\n        if (Array.isArray(result[key])) {\n          result[key].push(value);\n        } else {\n          result[key] = [result[key], value];\n        }\n      } else {\n        result[key] = value;\n      }\n    }\n    return result;\n  },\n  \n  // Validate email format\n  isValidEmail: (email) => {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email);\n  },\n  \n  // Validate phone format (basic)\n  isValidPhone: (phone) => {\n    const phoneRegex = /^[\\+]?[1-9][\\d\\s\\-\\(\\)]{7,}$/;\n    return phoneRegex.test(phone.replace(/\\s/g, ''));\n  },\n};\n\n// Animation utilities\nexport const animate = {\n  // Fade in element\n  fadeIn: (element, duration = APP_CONFIG.ANIMATION.normal) => {\n    element.style.opacity = '0';\n    element.style.transition = `opacity ${duration}ms ease-in-out`;\n    \n    performance.raf(() => {\n      element.style.opacity = '1';\n    });\n  },\n  \n  // Fade out element\n  fadeOut: (element, duration = APP_CONFIG.ANIMATION.normal) => {\n    element.style.transition = `opacity ${duration}ms ease-in-out`;\n    element.style.opacity = '0';\n    \n    setTimeout(() => {\n      element.style.display = 'none';\n    }, duration);\n  },\n  \n  // Slide up element\n  slideUp: (element, duration = APP_CONFIG.ANIMATION.normal) => {\n    element.style.maxHeight = element.scrollHeight + 'px';\n    element.style.transition = `max-height ${duration}ms ease-out`;\n    element.style.overflow = 'hidden';\n    \n    performance.raf(() => {\n      element.style.maxHeight = '0';\n    });\n  },\n  \n  // Slide down element\n  slideDown: (element, duration = APP_CONFIG.ANIMATION.normal) => {\n    element.style.maxHeight = '0';\n    element.style.transition = `max-height ${duration}ms ease-out`;\n    element.style.overflow = 'hidden';\n    \n    performance.raf(() => {\n      element.style.maxHeight = element.scrollHeight + 'px';\n    });\n  },\n};